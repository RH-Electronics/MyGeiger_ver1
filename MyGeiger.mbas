'----------------------VERSION 1.07--------------------------------------------'
program MyGeiger


'-------------------------------FONTS AND GRAPHICS-----------------------------'
const logo as byte[504] =
' (0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xE0, 0xF0, 0xF0,
'  0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0,
'  0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0xFE, 0xFF, 0x11, 0x11, 0x2E, 0xCE, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0xE0, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
'  0xFF, 0xFF, 0x3C, 0x90, 0xC0, 0xC0, 0xC0, 0x90, 0x1C, 0x7F, 0xFF, 0xFF,
'  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xE0, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x06, 0x03, 0x06, 0x0C, 0x18, 0xF0, 0x08, 0x07, 0x03,
'  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
'  0x0F, 0x07, 0x04, 0x04, 0x04, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0xC0, 0xE0, 0xF0, 0xF9, 0xF3, 0xF3, 0xF3, 0xF9, 0xF0, 0xE0, 0xC0, 0x80,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x0F, 0x0F, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0E, 0x0F,
'  0x1F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F,
'  0x0E, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0,
'  0x40, 0xC0, 0x00, 0xC0, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0xC0,
'  0x40, 0x5F, 0x1F, 0xD1, 0xD1, 0x00, 0x1F, 0x1F, 0xD1, 0xDF, 0x40, 0x5F,
'  0x1F, 0xD0, 0xDF, 0x40, 0x5F, 0x1F, 0x41, 0xDF, 0xC0, 0x41, 0x1F, 0xDF,
'  0xC1, 0x40, 0xDF, 0x1F, 0xD5, 0xD1, 0x40, 0xDF, 0x1F, 0xC5, 0xDB, 0x40,
'  0xC0, 0x00, 0x40, 0xC0, 0xC0, 0x40, 0x00, 0xC0, 0xC0, 0x40, 0x40, 0x00,
'  0xC0, 0xC0, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
'  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07,
'  0x01, 0x06, 0x00, 0x07, 0x07, 0x01, 0x07, 0x00, 0x00, 0x00, 0x07, 0x07,
'  0x05, 0x04, 0x00, 0x07, 0x07, 0x04, 0x04, 0x00, 0x07, 0x07, 0x05, 0x04,
'  0x00, 0x07, 0x07, 0x04, 0x04, 0x00, 0x00, 0x07, 0x07, 0x00, 0x00, 0x07,
'  0x07, 0x01, 0x06, 0x00, 0x07, 0x07, 0x04, 0x07, 0x00, 0x07, 0x07, 0x00,
'  0x07, 0x00, 0x04, 0x07, 0x07, 0x04, 0x00, 0x07, 0x07, 0x04, 0x04, 0x00,
'  0x05, 0x05, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)


( 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0x88, 0x88, 0xC4,
  0xC4, 0xC4, 0xC4, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC7, 0xC7, 0xC7,
  0xC7, 0xC7, 0xC7, 0xC7, 0xC7, 0xCF, 0x8F, 0x8F, 0x8F, 0x0F, 0x0F, 0x1F,
  0x1E, 0x1E, 0x3E, 0x3E, 0x7E, 0x7E, 0x7C, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8,
  0xF8, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x40, 0x44,
  0x44, 0x42, 0x52, 0xD2, 0xC9, 0xC9, 0x89, 0x09, 0x08, 0xC4, 0xC4, 0xC4,
  0xC4, 0xC4, 0xC4, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xDC, 0xDC,
  0xD8, 0x39, 0x39, 0x71, 0xF3, 0xF3, 0xE3, 0xE3, 0xC7, 0x87, 0x0F, 0x1F,
  0x1E, 0x3E, 0x7C, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE1, 0xC1, 0x83, 0x03,
  0x07, 0x0F, 0x1F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
  0xFC, 0xFC, 0xF8, 0xF0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x06, 0x3F, 0x3F, 0x3D, 0x00, 0x00, 0x1F, 0x1F, 0x3F,
  0x3F, 0x3F, 0x3F, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x3F, 0x3F,
  0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x1F, 0x3F, 0x3F, 0x3E,
  0x3C, 0x38, 0x00, 0x00, 0x03, 0x0F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
  0x3C, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
  0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x1F, 0x15, 0x15, 0x15, 0x15, 0x00, 0x1F, 0x1F,
  0x10, 0x10, 0x10, 0x10, 0x00, 0x1F, 0x1F, 0x15, 0x15, 0x15, 0x15, 0x00,
  0x00, 0x0E, 0x1F, 0x1F, 0x11, 0x11, 0x11, 0x00, 0x01, 0x01, 0x1F, 0x1F,
  0x01, 0x01, 0x00, 0x00, 0x1F, 0x1D, 0x05, 0x05, 0x1D, 0x17, 0x00, 0x00,
  0x1E, 0x1B, 0x11, 0x11, 0x1B, 0x0F, 0x00, 0x1F, 0x03, 0x06, 0x0C, 0x18,
  0x1F, 0x00, 0x11, 0x1F, 0x1F, 0x11, 0x00, 0x0E, 0x1F, 0x1F, 0x11, 0x11,
  0x11, 0x00, 0x17, 0x17, 0x15, 0x15, 0x1D, 0x1D, 0x00, 0x00, 0x00, 0x00,                       ' 0x1F, 0x20, 0x40, 0x20, 0x1F ,  ' V
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                       ' 0x38, 0x54, 0x54, 0x54, 0x18 ,  ' e
  0x00, 0x00, 0x00, 0x00, 0x00,
  0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00,                       ' 0x7C, 0x08, 0x04, 0x04, 0x08 ,  ' r
  0x7c, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00,                       ' 0x00, 0x60, 0x60, 0x00, 0x00 ,  ' .
  0x00, 0x42, 0x7f, 0x40, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x3e,                       ' 0x00, 0x42, 0x7F, 0x40, 0x00 ,  ' 1
  0x51, 0x49, 0x45, 0x3e, 0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x7F, 0x48,                       ' 0x3E, 0x51, 0x49, 0x45, 0x3E ,  ' 0
  0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                       ' 0x01, 0x71, 0x09, 0x05, 0x03 ,  ' 7
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )                                                    ' 0x7F, 0x48, 0x44, 0x44, 0x38 ,  ' b

const cpm_label as byte[23] =
  ( 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00,       'C
    0x7F, 0x09, 0x09, 0x09, 0x06, 0x00,       'P
    0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00,       'M
    0x00, 0x36, 0x36, 0x00, 0x00)             ':

const uSv_label as byte [23] =

  ( 0x46, 0x49, 0x49, 0x49, 0x31, 0x00,       'S
    0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00,       'v
    0x20, 0x10, 0x08, 0x04, 0x02, 0x00,       '/
    0x7F, 0x08, 0x04, 0x04, 0x78)             'h


const calib_label as byte [23] =
  ( 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00,       '+
    0x10, 0x10, 0x10, 0x10, 0x10, 0x00,       '-
    0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00,       'O
    0x7F, 0x08, 0x14, 0x22, 0x41)             'K

const lipo as byte [29] =
  ( 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00,
    0x00, 0x41, 0x7F, 0x41, 0x00, 0x00,
    0x7F, 0x09, 0x09, 0x09, 0x06, 0x00,
    0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00,
    0x02, 0x01, 0x51, 0x09, 0x06)

' Modified font to safe memory space
const fontlookup1 as byte[130] =
   (0x00, 0x00, 0x00, 0x00, 0x00 ,  ' sp
    0x1F, 0x20, 0x40, 0x20, 0x1F ,  ' !  "V"
    0x7E, 0x41, 0x41, 0x41, 0x7E ,  ' "
    0x3C, 0x3C, 0x3C, 0x3C, 0x3C ,  ' #   ' SCALE SYMBOL
    0x7F, 0x08, 0x14, 0x22, 0x41 ,  ' $   "K"
    0x7E, 0x71, 0x71, 0x71, 0x7E ,  ' %   'BATT 50%
    0x7e, 0x7F, 0x7F, 0x7F, 0x7e ,  ' &   'BATT 100%
    0x7e, 0x79, 0x79, 0x79, 0x7e ,  ' '   'BATT 75%
    0xC0, 0xE0, 0x7F, 0x02, 0x1C ,  ' (   'SOUND ON SYMBOL
    0x00, 0xE0, 0xE0, 0xE0, 0x00 ,  ' )   'POINT BIG  0x00, 0x41, 0x22, 0x1c, 0x00
    0x14, 0x08, 0x3E, 0x08, 0x14 ,  ' *
    0x7C, 0x04, 0x18, 0x04, 0x78 ,  ' +   'm for mSv/h
    0xFF, 0x40, 0x40, 0x20, 0x7C ,  ' ,   'u for uSv/h
    0x7E, 0x61, 0x61, 0x61, 0x7E ,  ' -   ' BATT EMPTY 25%
    0x00, 0x60, 0x60, 0x00, 0x00 ,  ' .
    0x20, 0x10, 0x08, 0x04, 0x02 ,  ' /
    0x3E, 0x51, 0x49, 0x45, 0x3E ,  ' 0
    0x00, 0x42, 0x7F, 0x40, 0x00 ,  ' 1
    0x42, 0x61, 0x51, 0x49, 0x46 ,  ' 2
    0x21, 0x41, 0x45, 0x4B, 0x31 ,  ' 3
    0x18, 0x14, 0x12, 0x7F, 0x10 ,  ' 4
    0x27, 0x45, 0x45, 0x45, 0x39 ,  ' 5
    0x3C, 0x4A, 0x49, 0x49, 0x30 ,  ' 6
    0x01, 0x71, 0x09, 0x05, 0x03 ,  ' 7
    0x36, 0x49, 0x49, 0x49, 0x36 ,  ' 8
    0x06, 0x49, 0x49, 0x29, 0x1E )  ' 9
'    0x00, 0x36, 0x36, 0x00, 0x00 ,  ' :
'    0x00, 0x56, 0x36, 0x00, 0x00 ,  ' ;
'    0x08, 0x14, 0x22, 0x41, 0x00 ,  ' <
'    0x14, 0x14, 0x14, 0x14, 0x14 ,  ' =
'    0x00, 0x41, 0x22, 0x14, 0x08 ,  ' >
'    0x02, 0x01, 0x51, 0x09, 0x06 ,  ' ?
'    0x32, 0x49, 0x59, 0x51, 0x3E ,  ' @
'    0x7e, 0x11, 0x11, 0x11, 0x7e ,  ' A         ' BATT FULL
'    0x7E, 0x7D, 0x7D, 0x7D, 0x7E ,  ' B         ' BATT Middle 1
'    0x3E, 0x41, 0x41, 0x41, 0x22 ,  ' C
'    0x7E, 0x41, 0x41, 0x41, 0x7E ,  ' D         ' BATT LOW
'    0x7E, 0x71, 0x71, 0x71, 0x7E ,  ' E         ' BATT Middle 2
'    0x7F, 0x09, 0x09, 0x09, 0x01 ,  ' F
'    0x3E, 0x41, 0x49, 0x49, 0x7A ,  ' G
'    0x7F, 0x08, 0x08, 0x08, 0x7F ,  ' H
'    0x00, 0x41, 0x7F, 0x41, 0x00 ,  ' I
'    0x20, 0x40, 0x41, 0x3F, 0x01 ,  ' J
'    0x7F, 0x08, 0x14, 0x22, 0x41 ,  ' K
'    0x7F, 0x40, 0x40, 0x40, 0x40 ,  ' L
'    0x7F, 0x02, 0x0C, 0x02, 0x7F )  ' M
'
'
'const fontlookup2 as byte[225] =
'   (0x7F, 0x04, 0x08, 0x10, 0x7F ,  ' N
'    0x3E, 0x41, 0x41, 0x41, 0x3E ,  ' O
'    0x7F, 0x09, 0x09, 0x09, 0x06 ,  ' P
'    0x3E, 0x41, 0x51, 0x21, 0x5E ,  ' Q
'    0x7F, 0x09, 0x19, 0x29, 0x46 ,  ' R
'    0x46, 0x49, 0x49, 0x49, 0x31 ,  ' S
'    0x01, 0x01, 0x7F, 0x01, 0x01 ,  ' T
'    0x3F, 0x40, 0x40, 0x40, 0x3F ,  ' U
'    0x1F, 0x20, 0x40, 0x20, 0x1F ,  ' V
'    0x3F, 0x40, 0x38, 0x40, 0x3F ,  ' W
'    0x63, 0x14, 0x08, 0x14, 0x63 ,  ' X
'    0x07, 0x08, 0x70, 0x08, 0x07 ,  ' Y
'    0x61, 0x51, 0x49, 0x45, 0x43 ,  ' Z  0x5A  90
'    0x00, 0x7F, 0x41, 0x41, 0x00 ,  ' [
'    0x55, 0x2A, 0x55, 0x2A, 0x55 ,  ' 55
'    0x00, 0x41, 0x41, 0x7F, 0x00 ,  ' ]
'    0x04, 0x02, 0x01, 0x02, 0x04 ,  ' ^
'    0x40, 0x40, 0x40, 0x40, 0x40 ,  ' _
'    0x00, 0x01, 0x02, 0x04, 0x00 ,  ' '
'    0x20, 0x54, 0x54, 0x54, 0x78 ,  ' a
'    0x7F, 0x48, 0x44, 0x44, 0x38 ,  ' b
'    0x38, 0x44, 0x44, 0x44, 0x20 ,  ' c
'    0x38, 0x44, 0x44, 0x48, 0x7F ,  ' d
'    0x38, 0x54, 0x54, 0x54, 0x18 ,  ' e
'    0x08, 0x7E, 0x09, 0x01, 0x02 ,  ' f
'    0x0C, 0x52, 0x52, 0x52, 0x3E ,  ' g
'    0x7F, 0x08, 0x04, 0x04, 0x78 ,  ' h
'    0x00, 0x44, 0x7D, 0x40, 0x00 ,  ' i
'    0x20, 0x40, 0x44, 0x3D, 0x00 ,  ' j
'    0x7F, 0x10, 0x28, 0x44, 0x00 ,  ' k
'    0x00, 0x41, 0x7F, 0x40, 0x00 ,  ' l
'    0x7C, 0x04, 0x18, 0x04, 0x78 ,  ' m
'    0x7C, 0x08, 0x04, 0x04, 0x78 ,  ' n
'    0x38, 0x44, 0x44, 0x44, 0x38 ,  ' o
'    0x7C, 0x14, 0x14, 0x14, 0x08 ,  ' p
'    0x08, 0x14, 0x14, 0x18, 0x7C ,  ' q
'    0x7C, 0x08, 0x04, 0x04, 0x08 ,  ' r
'    0x48, 0x54, 0x54, 0x54, 0x20 ,  ' s
'    0x04, 0x3F, 0x44, 0x40, 0x20 ,  ' t
'    0xFF, 0x40, 0x40, 0x20, 0x7C ,  ' u
'    0x1C, 0x20, 0x40, 0x20, 0x1C ,  ' v
'    0x3C, 0x40, 0x30, 0x40, 0x3C ,  ' w
'    0x44, 0x28, 0x10, 0x28, 0x44 ,  ' x
'    0x0C, 0x50, 0x50, 0x50, 0x3C ,  ' y
'    0x44, 0x64, 0x54, 0x4C, 0x44)   ' z


' Big font array for dose
const Zero as byte [24] = (
    0x00, 0xfc, 0x7a, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7a, 0xfc, 0x00, 0x00, 0x7e, 0xbc, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xbc, 0x7e, 0x00)   ' 0
const One as byte [24] = (
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7e, 0x00)   ' 1
const Two as byte [24] = (
    0x00, 0x00, 0x02, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x7a, 0xfc, 0x00, 0x00, 0x7e, 0xbd, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x81, 0x00, 0x00)   ' 2
const Thre as byte [24] = (
    0x00, 0x00, 0x02, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x7a, 0xfc, 0x00, 0x00, 0x00, 0x81, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xbd, 0x7e, 0x00)   ' 3
const Four as byte [24] = (
    0x00, 0xfc, 0x78, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x78, 0xfc, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x3d, 0x7e, 0x00)   ' 4
const Five as byte [24] = (
    0x00, 0xfc, 0x7a, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x02, 0x00, 0x00, 0x00, 0x00, 0x81, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xbd, 0x7e, 0x00)   ' 5
const Six as byte [24] = (
    0x00, 0xfc, 0x7a, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x02, 0x00, 0x00, 0x00, 0x7e, 0xbd, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xbd, 0x7e, 0x00)   ' 6
const Seven as byte [24] = (
    0x00, 0x00, 0x02, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7a, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7e, 0x00)   ' 7
const Eight as byte [24] = (
    0x00, 0xfc, 0x7a, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x7a, 0xfc, 0x00, 0x00, 0x7e, 0xbd, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xbd, 0x7e, 0x00)   ' 8
const Nine as byte [24] = (
    0x00, 0xfc, 0x7a, 0x86, 0x86, 0x86, 0x86, 0x86, 0x86, 0x7a, 0xfc, 0x00, 0x00, 0x00, 0x81, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xbd, 0x7e, 0x00)   ' 9

const KK as byte [24] = (
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)   ' space between numbers

'-------------------------------GLOBAL VARIABLES-------------------------------'

dim rreset as sbit at PORTC.RC0                ' display reset pin
    ddata  as sbit at PORTC.RC1                ' display data control pin
    light  as sbit at RA5_bit                  ' dispaly backlight pin
    diode  as sbit at RA1_bit                  ' LED pin
    alert  as sbit at RB2_bit                  ' alert pin

dim    event          as bit                    ' flags variables
dim    sound          as bit
dim    sek_over       as bit
dim    cpm_read_done  as bit
dim    voltage_period as bit
dim    klavisha       as bit
dim    buzzer_started as bit

dim    xx          as byte                        ' cpm array counter
dim    CF          as byte                        ' conversion factor
dim    n           as byte                        ' help to resolve first count bug
dim    scale_c     as byte                        ' bargraph scale
dim    hh          as byte                        ' byte for drawing fonts
dim    bbb         as byte                        ' PWM byte
dim    m_period    as byte                        ' byte for time
dim    sekunds     as byte                        ' byte for time
dim    sek_counter as byte                        ' byte for timer
dim    timer_cnt   as byte                        ' byte for timer
dim    button_period  as byte                     ' period to check buttons
dim    buzzer_counter as byte                     ' for sound counter
dim    BAT_TYPE  as byte                          ' battery settings bytes
       BAT_25    as byte
       BAT_50    as byte
       BAT_100   as byte
       BAT_START as byte

dim  adc_rd      as integer                    ' ADC readings
     tlong       as integer                    ' voltage mv


dim  cnt         as word                       ' counters
     cnt_s       as word
     sek_cnt     as word
     parid_cpm   as word                       ' rapid cpm changes
     ch          as word                       ' mod/div variable
     ALARM       as word                       ' ALARM
     nn          as word                       ' variable for driving display
     counts      as word                       ' events count

dim  old_cpm     as longword                   ' previous cpm
     cpm         as longword                   ' cpm
     dose        as longword                   ' dose
     dim CX      as longword[6]                ' moving average cpm array


dim  CPM_Display as char[10]                   ' cpm text for display
dim  DispV       as string[6]                  ' high voltage text
     sekunds_txt as string[3]                  ' sekunds text

'------------------------------------------------------------------------------'

'---------------------------TUBE INTERRUPT-------------------------------------'

 sub procedure interrupt()             ' Interrupt Settings
    if (TMR0IF_bit = 1) then

    if (buzzer_counter = 4) then
      PORTB.3 = 0
      buzzer_counter = 0
      buzzer_started = 0
      else
      if buzzer_started = 1 then
       PORTB.3 = not PORTB.3
      end if
      inc (buzzer_counter)
     end if
    TMR0 = 0xD2
    TMR0IF_bit = 0
  end if
 
  if (TMR1IF_bit = 1) then             ' Test Timer1 interrupt flag
                                       ' Turn off led
    diode = 0
    voltage_period = 1
    if(button_period = 4) then         ' check buttons every 250ms
     klavisha = 1
    else
     inc(button_period)
    end if
    
    if(sek_counter = 19) then
       sek_counter = 0
       sek_cnt = cnt_s
       cnt_s = 0
       sek_over = 1
      else
       inc(sek_counter)
    end if

    if(timer_cnt = m_period) then      ' When time elapsed
      counts = cnt                     ' Store result in counts
      cnt = 0                          ' Reset counter
      timer_cnt = 0                    ' Reset timer_cnt
      cpm_read_done = 1                ' Set flag = 1
     else
      inc(timer_cnt)                   ' Increment timer_cnt if not elapsed 10 second
    end if

    TMR1H = 0xE7                       ' First write higher byte to TMR1 0xCF2C
    TMR1L = 0x96                       ' Write lower byte to TMR1
    TMR1IF_bit = 0                     ' Clear Timer1 interrupt flag
  end if


  if(INTF_bit) then                    ' Test RB0/INT interrupt flag
    cnt = cnt + 1                      ' Count interrupts on RB0/INT pin
    cnt_s = cnt_s + 1

              if sound = 1 then
                  buzzer_started = 1
                  buzzer_counter = 0
                  PORTB.3 = 1
                  TMR0 = 0xD2
                  TMR0IE_bit = 1
              end if

    PORTB.1 = 1                        ' Generate Interrupt for external MCU
    nop
    PORTB.1 = 0
    event = 1
    INTF_bit = 0                       ' Clear RB0/INT interrupt flag

  end if

end sub

'------------------------NOKIA DISPLAY PROCEDURES------------------------------'
sub procedure NOK_init()

  ddata = 0
  SPI1_Write (0x21)
  SPI1_Write (0xBF)      'C5    0xBF if display are too dark
  SPI1_Write (0x06)
  SPI1_Write (0x13)
  SPI1_Write (0x20)
  SPI1_Write (0x0C)
  ddata = 1

end sub

sub procedure NOK_clear()
ddata = 1
 for nn = 0 to 503
    SPI1_Write (0x00)
 next nn


end sub

sub procedure NOK_goto(Dim x,y as byte)

  SetBit(x,7)
  SetBit(y,6)
  ddata = 0
  SPI1_Write (y)
  SPI1_Write (x)
  ddata = 1

end sub

sub procedure NOK_Chr(Dim symlcd as Byte)
Dim l, m as Byte

    For l = 1 to 5
      m = (symlcd - 32)
      m = m * 5
      m = m + l
      m = m - 1
      SPI1_Write(fontlookup1[m])
    Next l
  SPI1_Write(0x00)          ' Space between characters

end sub
Sub Procedure NOK_Out(Dim x, y as byte, Dim Byref sentance as string)
Dim v as byte

  NOK_goto(x,y)
  For v = 0 to length(sentance)-1
    NOK_Chr(sentance[v])
  Next v
End Sub

sub procedure NOK_Chr_Big (dim px, py as byte, dim digit as byte)
dim hh as byte

     NOK_goto (px, py)
     py = py + 1
     digit = 48+digit
     if digit = "0" then
         for hh = 0 to 11
          SPI1_Write (Zero[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Zero[hh])
     next hh
     end if

     if digit = "1" then
         for hh = 0 to 11
          SPI1_Write (One[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (One[hh])
     next hh
     end if

     if digit = "2" then
         for hh = 0 to 11
          SPI1_Write (Two[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Two[hh])
     next hh
     end if

     if digit = "3" then
         for hh = 0 to 11
          SPI1_Write (Thre[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Thre[hh])
     next hh
     end if

     if digit = "4" then
         for hh = 0 to 11
          SPI1_Write (Four[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Four[hh])
     next hh
     end if

     if digit = "5" then
         for hh = 0 to 11
          SPI1_Write (Five[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Five[hh])
     next hh
     end if

     if digit = "6" then
         for hh = 0 to 11
          SPI1_Write (Six[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Six[hh])
     next hh
     end if

     if digit = "7" then
         for hh = 0 to 11
          SPI1_Write (Seven[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Seven[hh])
     next hh
     end if

     if digit = "8" then
         for hh = 0 to 11
          SPI1_Write (Eight[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Eight[hh])
     next hh
     end if

     if digit = "9" then
         for hh = 0 to 11
          SPI1_Write (Nine[hh])
     next hh
     NOK_goto (px, py)
     for hh = 12 to 23
          SPI1_Write (Nine[hh])
     next hh
     end if

end sub
'------------------------------------------------------------------------------'

'--------------------------CALIBRATION PROCEDURE-------------------------------'
 sub procedure calibration()
    'GIE_bit = 0
    TMR1IE_bit = 0
    TMR0IE_bit = 0
    INTE_bit = 0
    PORTB.3 = 0
    alert = 0
    light = 1
    diode = 0
    ' make tube voltage safe during calibration
      bbb = BAT_START         ' first start PWM duty cycle app 25%
      PR2       = 249         ' Set PWM at 4KHz
      CCPR1L    = bbb         ' Set PWM Duty-Cycle
      CCP1CON   = %00001100   ' Mode select = PWM
      T2CON     = %00000100   ' Timer2 ON prescale
    
    NOK_clear()
      NOK_goto (30, 4)
      for nn = 0 to 22
       SPI1_Write (calib_label[nn])
      next nn


    NOK_Out(0, 0, "*   0.0      *")

     ch = (CF div 100) mod 10
     NOK_goto(42, 0)
     NOK_Chr (48+ch)
     ch = (CF div 10) mod 10
     NOK_Chr (48+ch)
     ch = CF mod 10
     NOK_Chr (48+ch)


    CF_calib:
    while (1)
     if Button (PORTB, 7, 150, 1) then
       inc (CF)
         if CF> 0xFA then
          dec (CF)
         end if
     ch = (CF div 100) mod 10
     NOK_goto(42, 0)
     NOK_Chr (48+ch)
     ch = (CF div 10) mod 10
     NOK_Chr (48+ch)
     ch = CF mod 10
     NOK_Chr (48+ch)

     end if

     if Button (PORTB, 6, 150, 1) then
       dec (CF)
         if CF<0x01 then
           inc (CF)
         end if
     ch = (CF div 100) mod 10
     NOK_goto(42, 0)
     NOK_Chr (48+ch)
     ch = (CF div 10) mod 10
     NOK_Chr (48+ch)
     ch = CF mod 10
     NOK_Chr (48+ch)

     end if

     if Button (PORTB, 5, 150, 1) then         'ok
       EEPROM_Write (0x01, CF)
       goto bat_select
     end if
    wend


    bat_select:
    NOK_goto (30, 5)
     for nn = 0 to 28
       SPI1_Write (lipo[nn])
      next nn
      if Button (PORTB, 7, 150, 1) then    'YES there is LIPO
        EEPROM_write (0x00, 0x00)
        goto exit_calibration
      end if
      if Button (PORTB, 6, 150, 1) then    ' NO, there is Ni-MH
        EEPROM_write (0x00, 0x01)
        goto exit_calibration
      end if
      goto bat_select

    exit_calibration:

      NOK_clear()
       counts = 0
       cpm = 0
       dose = 0
       timer_cnt = 0
       cpm_read_done = 0
       TMR0 = 0xD2
       TMR1H = 0xE7                         ' First write higher byte to TMR1
       TMR1L = 0x96                         ' Write lower byte to TMR1
       TMR1IF_bit = 0
       TMR0IF_bit = 0
       TMR1IE_bit = 1
       TMR0IE_bit = 1
       INTE_bit   = 1
 end sub

'--------------------------ALERT SET PROCEDURE---------------------------------'
 sub procedure signalization()

   dim
   const AAA as byte [58] = (
    0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x7f, 0x49, 0x49, 0x49, 0x41, 0x00, 0x01, 0x01, 0x7f, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x00,
    0x7f, 0x40, 0x40, 0x40, 0x40, 0x00, 0x7e, 0x11, 0x11, 0x11, 0x7e, 0x00, 0x7f, 0x09, 0x19, 0x29, 0x46, 0x00, 0x7f, 0x02, 0x0c, 0x02, 0x7f, 0x00, 0x02, 0x01, 0x51, 0x09, 0x06 )       ' SET ALARM?
   dim zzz as word
   dim txt1 as char[5]

   NOK_clear()
   NOK_goto (13, 0)
      for nn = 0 to 57
       SPI1_Write (AAA[nn])
      next nn
   NOK_Out(0, 2, "     600      ")
    ALARM = 600

    for zzz = 0 to 30000
       if Button (PORTB, 7, 50, 1) then
        goto CHANGE
       end if
    next zzz
    goto CHANGE2

    CHANGE:
       NOK_goto (30, 4)
      for nn = 0 to 22
       SPI1_Write (calib_label[nn])
      next nn
    while (1)
     if Button (PORTB, 7, 150, 1) then
       ALARM = ALARM + 10
         if ALARM>5000 then
          ALARM = 5000
         end if
      WordToStr (ALARM, txt1)
      ltrim (txt1)
      NOK_Out (0, 2, "*            *")
      NOK_Out (30, 2, txt1)
     end if

     if Button (PORTB, 6, 150, 1) then
       ALARM = ALARM - 10
         if ALARM<60 then
           ALARM = 60
         end if
      WordToStr (ALARM, txt1)
      ltrim(txt1)
      NOK_Out (0, 2, "*            *")
      NOK_Out (30, 2, txt1)

     end if

     if Button (PORTB, 5, 150, 1) then
       goto CHANGE2
     end if
    wend
    CHANGE2:
    ALARM = ALARM / 60
    NOK_clear()
 end sub

'------------------------------PRINT DOSE--------------------------------------'
 sub procedure dosextract()
                            if dose < 100000 then
                                NOK_OUT(54,3,",")
                                ch = (dose div 10000)
                                NOK_Chr_Big(5, 2, ch)
                                NOK_goto (17, 2)
                                 for hh = 0 to 11
                                 SPI1_Write (KK[hh])
                                 next hh
                                 NOK_goto (17, 3)
                                 for hh = 12 to 23
                                 SPI1_Write (KK[hh])
                                 next hh
                                NOK_out(17,3,")")
                                ch = (dose div 1000) mod 10
                                NOK_Chr_Big(22, 2, ch)
                                ch = (dose div 100) mod 10
                                NOK_Chr_Big (34, 2, ch)
                              else
                               if dose < 1000000 then
                                NOK_OUT(54,3,",")

                                    ch = (dose div 100000)
                                    NOK_Chr_Big(5, 2, ch)
                                    ch = (dose div 10000) mod 10
                                    NOK_Chr_Big (17, 2, ch)
                                    NOK_goto (29, 2)
                                     for hh = 0 to 11
                                     SPI1_Write (KK[hh])
                                     next hh
                                     NOK_goto (29, 3)
                                     for hh = 12 to 23
                                     SPI1_Write (KK[hh])
                                     next hh
                                    NOK_Out (29, 3, ")")
                                    ch = (dose div 1000) mod 10
                                    NOK_Chr_Big (34, 2, ch)
                                    else
                                          NOK_OUT(54,3,"+")
                                          ch = (dose div 10000000)
                                          NOK_Chr_Big (5, 2, ch)
                                          NOK_goto (17, 2)
                                           for hh = 0 to 11
                                           SPI1_Write (KK[hh])
                                           next hh
                                           NOK_goto (17, 3)
                                           for hh = 12 to 23
                                           SPI1_Write (KK[hh])
                                           next hh
                                          NOK_Out (17, 3, ")")
                                          ch = (dose div 1000000) mod 10
                                          NOK_Chr_Big (22, 2, ch)
                                          ch = (dose div 100000) mod 10
                                          NOK_Chr_Big (34, 2, ch)




                                end if
                            end if

   end sub
'---------------------END OF SUB PROCEDURES------------------------------------'

'--------------------------MAIN PROGRAM----------------------------------------'
main:

' variables settings for start
m_period = 59                            ' start with 3 seconds period
sekunds = 3
sek_over = 0
sek_counter = 0
sek_cnt = 0
alert = 0
sound = 1
diode = 0
light = 1
counts = 0
cpm = 0
timer_cnt = 0
cpm_read_done = 0
ALARM = 10
n = 0
cnt_s = 0
cnt   = 0
voltage_period = 0
button_period = 0
buzzer_counter = 0
buzzer_started = 0

' PIC registers set
CMCON = 0x07
TRISB = %11100001
PORTB = %00000001
TRISC = %00000000
'-------------------READ EEPROM------------------------------------------------'
CF = EEPROM_Read (0x01)
BAT_TYPE = EEPROM_Read (0x00)

OPTION_REG = %10000000
INTCON = %00000000

PIE1 = %00000000
PIE2 = %00000000
PIR1 = %00000000
PIR2 = %00000000
TRISA.0 = 1
TRISA.2 = 1
TRISA.3 = 1
TRISA.4 = 0
TRISA.5 = 0
TRISA.1 = 0

''-------------------READ EEPROM------------------------------------------------'
'CF = EEPROM_Read (0x01)
'BAT_TYPE = EEPROM_Read (0x00)

'    if BAT_TYPE = 0x01 then   ' Ni-MH type      EXTRA LOW
'        BAT_START = 0x41                '41       65
'        BAT_25 = 0x53                   '53       83
'        BAT_50 = 0x49                   '49       73
'        BAT_100= 0x44                   '44      68
'      else                    'LIPO type
'        BAT_START = 0x5A '            5A       90
'        BAT_25 = 0x78    '          78        120
'        BAT_50 = 0x67    '           67        103
'        BAT_100= 0x5D    '           5D        93
'     end if
'---------------SET BATTERY LIMITS---------------------------------------------'
    if BAT_TYPE = 0x01 then   ' Ni-MH type      DEFAULT
        BAT_START = 0x3C                '3C    60 (was 57)
        BAT_25 = 0x4E                   '4E    78 (was 75)
        BAT_50 = 0x44                   '44    68 (was 65)
        BAT_100= 0x3F                   '3F    63 (was 60)
      else                    'LIPO type
        BAT_START = 0x53                '53     83 (was 80)
        BAT_25 = 0x70                   '70      112 (was 110)
        BAT_50 = 0x65                   '65      101 (was 98)
        BAT_100= 0x55                   '55       85 (was 82)
     end if


'------------------SET ADC AND PWM---------------------------------------------'
bbb = BAT_START             ' first start PWM duty cycle app 25%

ADCON1 = %10001111          'Vref +1.24V    %10001111
ADCON0 = %00000001

PR2       = 249         ' Set PWM at 4KHz
CCPR1L    = bbb         ' Set PWM Duty-Cycle
CCP1CON   = %00001100   ' Mode select = PWM
T2CON     = %00000100   ' Timer2 ON prescale

'------------------START HARDWARE SPI------------------------------------------'
SPI1_init()
delay_ms(20)

'------------------START 5110 NOKIA DISPLAY------------------------------------'
rreset = 1
ddata = 1

NOK_Init()

delay_ms(20)
NOK_clear()
NOK_goto (0,0)

for nn = 0 to 503
  SPI1_Write (logo[nn])
next nn

'------------------START UART AT 2400 BAUD-------------------------------------'
UART1_Init(2400)
delay_ms(1000)

'------------------START BUZZER DRIVER-----------------------------------------'
'Sound_init (PORTB, 3)       ' already not used

'------------------ASKING FOR ALERT SETTINGS-----------------------------------'
STARTUEM:
signalization()

'------------------SET 16 BIT TIMER--------------------------------------------'
MEASURE:

  cpm = 0
  timer_cnt = 0
  cpm_read_done = 0

  TMR1H = 0xE7                         ' First write higher byte to TMR1
  TMR1L = 0x96                         ' Write lower byte to TMR1
  T1CON = 0x35                         ' Timer1 prescaler settings
  PIE1 = %00000001
  TMR1IE_bit = 1                       ' Enable Timer1 overflow interrupt
  TMR1IF_bit = 0
  INTEDG_bit = 0                       ' Interrupt on RB0/INT pin is edge triggered, setting it on low edge
  TMR0IF_bit = 0

'------------------ZEROING ARRAY-----------------------------------------------'
  for xx = 0 to 5
   CX[xx] = 0
  next xx


'------------------PREPARE DISPLAY---------------------------------------------'
 PRINT_LABELS:

 NOK_goto (60, 3)

      for nn = 0 to 22
       SPI1_Write (uSv_label[nn])
      next nn


 NOK_goto (0, 5)
   for nn = 0 to 22
   SPI1_Write (cpm_label[nn])
  next nn
  NOK_OUT (78, 0, "!")
  NOK_OUT (40, 0, "(")

'------------------ALLOW INTERRUPTS NOW----------------------------------------'
  INTCON = %11010000                        ' Set GIE, PIE, INTE (0xD0)
  cpm_read_done = 0
  counts = 0
  xx=0


'-----------------ENDLESS LOOP-------------------------------------------------'
  while(1)

      if voltage_period = 1 then              'correct HV every 50ms
                  adc_rd = ADC_Read(0)

                  if adc_rd > 168 then             '338 for 1.25V ; 168 for 2.50V
                    dec (bbb)
                     if bbb < 24 then
                      bbb = 24
                     end if

                    CCPR1L = bbb
                    CCP1CON   = %00001100
                    T2CON     = %00000100

                  end if

                  if adc_rd < 161 then          '326 for 1.25V ; 161 for 2.50V
                    inc (bbb)
                     if bbb > 127 then
                      bbb = 127
                     end if

                    CCPR1L = bbb
                    CCP1CON   = %00001100
                    T2CON     = %00000100

                  end if
      voltage_period = 0
      end if
      
      if (klavisha = 1) then          ' check if buttons pressed
          if PORTB.5 = 1 then
           delay_ms(100)
            if PORTB.5 = 1 then
            light = not light
            end if
            
          end if
          
          if PORTB.7 = 1 then
           sound = not sound
           if sound  = 1 then
                 NOK_OUT (40, 0, "(")
               else
                 NOK_OUT (40, 0, " ")
           end if
          end if
          
         klavisha = 0
      end if
      

          if event = 1 then

            diode = 1
'              if sound = 1 then                   ' not used now
'               'Sound_Play (4000, 1)
'              end if
            event = 0       ' reset event flag

          end if

          if sek_over = 1 then
          'GIE_bit = 0
          TMR1IE_bit = 0
                  if sek_cnt > ALARM then
                    alert = 1
                    light = 1
                    else
                    alert = 0

                  end if

                 NOK_Out (0,4, "              ")


                 ByteToStr (sekunds, sekunds_txt)
                 ltrim (sekunds_txt)
                 NOK_OUT (0, 0, "     ")
                 NOK_OUT (0, 0, sekunds_txt)
                 NOK_goto(0, 4)
                  if sek_cnt>13 then sek_cnt = 13
                  end if
                 for scale_c = 0 to sek_cnt
                   NOK_Chr ("#")
                 next scale_c

                  adc_rd = ADC_Read(0)

                  tlong = adc_rd * 2.45             '1.21 for 1.25V ; 2.44 for 2.5V
                  IntToStr (tlong, Dispv)
                  ltrim (Dispv)
                  NOK_Out (60, 0, Dispv)

'                  ByteToStr (bbb, bbb_display)
'                  NOK_Out (0,1, bbb_display)


                 sekunds = sekunds - 1
                 sek_over = 0
                 TMR1IE_bit = 1
          end if



    if cpm_read_done = 1 then           ' When interrupt occur
      TMR1IE_bit = 0                      ' Disable interrupts


        if n = 0 then                   'jjjjj
            n = 1
                  m_period = 199
                  sekunds = 10
            cpm = sek_cnt
            goto DD
            else

                  CX[xx] = counts
                   xx = xx + 1
                   if xx>5 then
                      xx=0
                   end if
                  old_cpm = cpm
                  cpm = CX[0] + CX[1] + CX[2] + CX[3] + CX[4] + CX[5]

                  if old_cpm >= cpm then
                   parid_cpm = old_cpm - cpm
                  else
                   parid_cpm = cpm - old_cpm
                  end if

                    if parid_cpm >=50 then
                      cpm = counts * 6
                      for xx = 0 to 5
                       CX[xx] = counts
                      next xx
                      xx = 0

                     end if

                  DD:
                  dose = cpm * CF                  ' Convert CPM to uSv/h (cpm * conversion factor  = uSv/h);
                  LongWordToStr (cpm, CPM_Display)
                  ltrim (CPM_Display)
                  UART1_Write_Text(CPM_Display)
                  UART1_Write_Text(" ")
                  NOK_Out (24, 5, "          ")
                  NOK_out (24, 5, CPM_Display)
                  dosextract()
                  m_period = 199
                  sekunds = 10

                   if alert = 0 then
                    light = 0
                   end if



         end if

            if bbb <= BAT_100 then
            NOK_OUT(50,0,"&")        'BATT 100%
              else
                if bbb > BAT_50 then
                NOK_OUT(50,0,"%")     'BATT 50%
                else
                NOK_OUT(50,0,"'")      'BATT 75%
                end if
            end if

           if bbb >= BAT_25 then      'BATT 25%
                NOK_OUT(50,0,"-")
           end if



      if Button (PORTB, 6, 50, 1) then calibration
        m_period = 199
        sekunds = 10
      goto PRINT_LABELS
      end if
      cpm_read_done = 0                ' Set flag = 0
      TMR1IE_bit = 1                      ' Enable interrupts

    end if

  wend
end.